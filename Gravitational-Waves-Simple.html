<html>
	<head>
		<title>Gravitational Waves</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		
		<!-- Google Analytics Code -->
		<!-- <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		  ga('create', 'UA-103589215-2', 'auto');
		  ga('send', 'pageview');

		</script>
		 -->

		  <script type="text/javascript" src="ProjectData/strain.json"></script>
		 <script type="text/javascript" src="ProjectData/straintimes.json"></script>
		 <script type="text/javascript" src="ProjectData/ntemplate.json"></script>
		 <script type="text/javascript" src="ProjectData/ntemplatetimes.json"></script>
		 <script type="text/javascript" src="ProjectData/snr.json"></script>
		 <script type="text/javascript" src="ProjectData/snrtimes.json"></script>
	</head>
	<body style='margin:0px; display: block;'>
		<div id="containAll" style='margin:0px;width:100%; height: 100%; font-size: 0; display: inline-block;'> 
			<div id="signaldisplayH" style='margin:0px;width:100%; height: 30%;overflow: hidden;position: relative;z-index: 4; display: inline-block;'>

			</div>
			<div id="gwavedisplayH" style='margin:0px;width:100%; height: 30%;overflow: hidden;position: relative;z-index: 4; display: inline-block;'>

			</div>
			<div id="autocrdisplayH" style='margin:0px;width:100%; height: 40%;overflow: hidden;position: relative;z-index: 4; display: inline-block;'>

			</div>
		</div>


		<script type="text/javascript">


		darkmode = false

		if (darkmode) {
			document.body.style.background = 'black'
		}

		function graphToSvgY(value, graphymin, graphymax) {
			if (graphymin == graphymax) {
				graphymin = graphymin - 1
				graphymax = graphymax + 1
				console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphymax + ' and Min value : ' + graphymin)
			}
			if (graphymin > graphymax) {
				temp = graphymin
				graphymin = graphymax
				graphymax = temp
				console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphymax + ' and Min value : ' + graphymin)
			}
			y = ((-80)/(graphymax - graphymin))*(value - graphymin) + 90
			return y
		}

		function graphToScaledY(value, graphymin, graphymax, aspectratio) {
			if(aspectratio > 1) {
				if (graphymin == graphymax) {
					graphymin = graphymin - 1
					graphymax = graphymax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}
				if (graphymin > graphymax) {
					temp = graphymin
					graphymin = graphymax
					graphymax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}
				y = ((-80)/(graphymax - graphymin))*(value - graphymin) + 90
				
			}
			else {
				if (graphymin == graphymax) {
					graphymin = graphymin - 1
					graphymax = graphymax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}
				if (graphymin > graphymax) {
					temp = graphymin
					graphymin = graphymax
					graphymax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}
				aspectratio = 1/aspectratio
				vl = (100*(1 - aspectratio)/2) + (10*aspectratio)
				vh = (100*(aspectratio + 1)/2) - (10*aspectratio)
				y = ((vl - vh)/(graphymax - graphymin))*(value - graphymin) + vh
				// console.log(x)
				// console.log(v1, v2)
				// y = (((v2 - v1)/(100))*(y)) + v1
			}

			return y
		}

		function svgToGraphY(percentvalue, graphymin, graphymax, aspectratio) {
			if(aspectratio > 1) {
				if (graphymin == graphymax) {
					graphymin = graphymin - 1
					graphymax = graphymax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}
				if (graphymin > graphymax) {
					temp = graphymin
					graphymin = graphymax
					graphymax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}

				y = ((percentvalue - 90)*(graphymax - graphymin)/((-1)*80)) + graphymin
				
			}
			else {
				if (graphymin == graphymax) {
					graphymin = graphymin - 1
					graphymax = graphymax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}
				if (graphymin > graphymax) {
					temp = graphymin
					graphymin = graphymax
					graphymax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphymax + ' and Min value : ' + graphymin)
				}
				aspectratio = 1/aspectratio
				vl = (100*(1 - aspectratio)/2) + (10*aspectratio)
				vh = (100*(aspectratio + 1)/2) - (10*aspectratio)

				// y = ((vl - vh)/(graphymax - graphymin))*(value - graphymin) + vh
				y = (((percentvalue - vh)*(graphymax - graphymin))/(vl - vh)) + graphymin
				// console.log(x)
				// console.log(v1, v2)
				// y = (((v2 - v1)/(100))*(y)) + v1
			}

			return y
		}


		function graphToSvgX(value, graphxmin, graphxmax) {
			if (graphxmin == graphxmax) {
				graphxmin = graphxmin - 1
				graphxmax = graphxmax + 1
				console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
			}
			if (graphxmin > graphxmax) {
				temp = graphxmin
				graphxmin = graphxmax
				graphxmax = temp
				console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
			}
			x = ((80)/(graphxmax - graphxmin))*(value - graphxmin) + 10
			return x
		}

		function graphToScaledX(value, graphxmin, graphxmax, aspectratio) {
			if (aspectratio <= 1) {
				if (graphxmin == graphxmax) {
					graphxmin = graphxmin - 1
					graphxmax = graphxmax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}
				if (graphxmin > graphxmax) {
					temp = graphxmin
					graphxmin = graphxmax
					graphxmax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}
				x = ((80)/(graphxmax - graphxmin))*(value - graphxmin) + 10
			}
			else {
				if (graphxmin == graphxmax) {
					graphxmin = graphxmin - 1
					graphxmax = graphxmax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}
				if (graphxmin > graphxmax) {
					temp = graphxmin
					graphxmin = graphxmax
					graphxmax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}
				vl = (100*(1 - aspectratio)/2) + (10*aspectratio)
				vh = (100*(aspectratio + 1)/2) - (10*aspectratio)
				x = ((vh - vl)/(graphxmax - graphxmin))*(value - graphxmin) + vl
				// console.log(x)
				// console.log(v1, v2)
				// y - y1 = (y2 - y1)/(x2 - x1) * (x - x1)
				// x = (((v2 - v1)/(90))*(x - 10)) + v1
				// console.log(x)
				// console.log('_') 
			}
			return x
		}

		function svgToGraphX(percentvalue, graphxmin, graphxmax, aspectratio) {
			if (aspectratio <= 1) {
				if (graphxmin == graphxmax) {
					graphxmin = graphxmin - 1
					graphxmax = graphxmax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}
				if (graphxmin > graphxmax) {
					temp = graphxmin
					graphxmin = graphxmax
					graphxmax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}

				x = ((percentvalue - 10)*(graphxmax - graphxmin)/80) + graphxmin
			}
			else {
				if (graphxmin == graphxmax) {
					graphxmin = graphxmin - 1
					graphxmax = graphxmax + 1
					console.log('Conversion error, maximum value is equal to minimum value. Max value was raised by 1 and Min value was reduced by 1. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}
				if (graphxmin > graphxmax) {
					temp = graphxmin
					graphxmin = graphxmax
					graphxmax = temp
					console.log('Conversion error, maximum value less than minimum value. Values were swapped. Max value : ' + graphxmax + ' and Min value : ' + graphxmin)
				}
				vl = (100*(1 - aspectratio)/2) + (10*aspectratio)
				vh = (100*(aspectratio + 1)/2) - (10*aspectratio)

				// x = ((vh - vl)/(graphxmax - graphxmin))*(value - graphxmin) + vl

				x = ((percentvalue - vl)*(graphxmax - graphxmin)/(vh - vl)) + graphxmin
				// console.log(x)
				// console.log(v1, v2)
				// y - y1 = (y2 - y1)/(x2 - x1) * (x - x1)
				// x = (((v2 - v1)/(90))*(x - 10)) + v1
				// console.log(x)
				// console.log('_') 
			}
			return x
		}

		function isInt(n){
			return Number(n) === n && n % 1 === 0;
		}

		function isFloat(n){
			return Number(n) === n && n % 1 !== 0;
		}

		function gridtickvalues(valmin, valmax, ticksexpected) {
			expstring = ((valmax - valmin)/ticksexpected).toExponential()
			majorgridorder = parseFloat(Math.pow(10 , expstring.slice(expstring.indexOf('e') + 1)))
			// console.log(expstring)
			if (expstring.indexOf('.') != -1) {
				majorgriddivision = parseFloat(expstring.slice(0, expstring.indexOf('.'))*majorgridorder)	
			}
			else {
				majorgriddivision = parseFloat(expstring.slice(0, expstring.indexOf('e'))*majorgridorder)
			}
			
			// console.log(majorgriddivision)
			// console.log(majorgridorder)

			integerchoices = [1,2,5,10]
			for(choice = 0; choice < integerchoices.length - 1; choice++) {
				if (majorgriddivision < integerchoices[choice + 1]*majorgridorder) {
					majorgriddivisionchoice = majorgridorder*integerchoices[choice]
					break
				}
			}
			// console.log(majorgriddivisionchoice)

			if(valmin > 0) {
				majorgridstart = Math.ceil(valmin/majorgriddivisionchoice)*majorgriddivisionchoice;
				majorgridstart = majorgridstart - majorgriddivisionchoice
			}
			else if(valmin < 0) {
				majorgridstart = Math.floor(valmin/majorgriddivisionchoice)*majorgriddivisionchoice;
			}
			else{
				majorgridstart = majorgriddivisionchoice;
			}

			// majorgridstart = majorgridstart - majorgriddivisionchoice
			// console.log(majorgridstart, (valmax + majorgriddivisionchoice), majorgriddivisionchoice)

			majortickvalues = []
			for(majoraxispoint = majorgridstart; majoraxispoint < (valmax + majorgriddivisionchoice); majoraxispoint = majoraxispoint + majorgriddivisionchoice) {
				majortickvalues.push(majoraxispoint)
			}

			return majortickvalues
		}

		function updateGraphZoom(graphname, newMinMax) {
			gdata = graphData[graphname]

			svgElement = gdata.svgElement

			if (newMinMax.xmin != 0) {
				gdata.xmin = newMinMax.xmin || gdata.xmin
			}
			else {
				gdata.xmin = 0
			}

			if (newMinMax.xmax != 0) {
				gdata.xmax = newMinMax.xmax || gdata.xmax
			}
			else {
				gdata.xmax = 0
			}

			if (newMinMax.ymin != 0) {
				gdata.ymin = newMinMax.ymin || gdata.ymin
			}
			else {
				gdata.ymin = 0
			}

			if (newMinMax.ymax != 0) {
				gdata.ymax = newMinMax.ymax || gdata.ymax
			}
			else {
				gdata.ymax = 0
			}

			aratio = gdata.aspectratio

			if (gdata.unitAspectRatio == 'yes') {
				if (gdata.fixAxis == 'yaxis') {
					if (gdata.fixAxisStretchCentrally == 'yes') {
						centre = (gdata.xmax + gdata.xmin)/2
						gdata.xmin = centre - ((gdata.ymax - gdata.ymin)*aratio/2)
						gdata.xmax = centre + ((gdata.ymax - gdata.ymin)*aratio/2)
					}
					else {
						gdata.xmax = gdata.xmin + (gdata.ymax - gdata.ymin)*aratio
					}
					
				}
				else {
					if (gdata.fixAxisStretchCentrally == 'yes') {
						centre = (gdata.ymax + gdata.ymin)/2
						gdata.ymin = centre - ((gdata.xmax - gdata.xmin)*aratio/2)
						gdata.ymax = centre + ((gdata.xmax - gdata.xmin)*aratio/2)
					}
					else {
						gdata.ymax = gdata.ymin + (gdata.xmax - gdata.xmin)*aratio	
					}
					
				}
			}

			if (gdata.yaxisvisibility == 'yes') {
				var lineElement = gdata.yaxisElement
				lineElement.setAttribute('x1', graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) + '%');
				lineElement.setAttribute('y1', graphToScaledY(gdata.ymax, gdata.ymin, gdata.ymax, aratio) + '%');
				lineElement.setAttribute('x2', graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) + '%')
				lineElement.setAttribute('y2', graphToScaledY(gdata.ymin, gdata.ymin, gdata.ymax, aratio) + '%');
				gdata.yaxisElement = lineElement
			}

			if (gdata.xaxisvisibility == 'yes') {
				var lineElement = gdata.xaxisElement
				lineElement.setAttribute('x1', graphToScaledX(gdata.xmin, gdata.xmin, gdata.xmax, aratio) + '%');
				lineElement.setAttribute('y1', graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) + '%');
				lineElement.setAttribute('x2', graphToScaledX(gdata.xmax, gdata.xmin, gdata.xmax, aratio) + '%')
				lineElement.setAttribute('y2', graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) + '%');
				gdata.xaxisElement = lineElement
			}

			deleteSegments(gdata.xmajorgridElements)

			if (gdata.xmajorgridlinesvisibility == 'yes') {
				xmajortickvalues = gridtickvalues(gdata.xmin, gdata.xmax, ticks)
				gdata.xmajorgridElements = []
				for (m = 0; m < xmajortickvalues.length; m++) {
					ticklocation = xmajortickvalues[m]
					var lineElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
					ylength = (gdata.ymax - gdata.ymin)
					if (gdata.xmajorgridlinesextension == 'yes') {
						lineElement.setAttribute('x1', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(gdata.ymin - (ylength)/2, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(gdata.ymax + (ylength)/2, gdata.ymin, gdata.ymax, aratio) + '%');
						
					}
					else {
						lineElement.setAttribute('x1', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(gdata.ymin, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(gdata.ymax, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('id', gdata.name + '-xmajorgridline-' + m)
					}
					lineElement.style.stroke = gdata.xmajorgridcolor
					lineElement.style.strokeWidth = gdata.xmajorgridthickness + '%';
					gdata.xmajorgridElements.push(lineElement)
					svgElement.appendChild(lineElement);
				}
				gdata.xmajorgridticks = xmajortickvalues
			}

			deleteSegments(gdata.ymajorgridElements)

			if (gdata.ymajorgridlinesvisibility == 'yes') {
				ymajortickvalues = gridtickvalues(gdata.ymin, gdata.ymax, ticks)
				gdata.ymajorgridElements = []
				for (m = 0; m < ymajortickvalues.length; m++) {
					ticklocation = ymajortickvalues[m]
					var lineElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
					xlength = (gdata.xmax - gdata.xmin)
					if (gdata.ymajorgridlinesextension == 'yes') {
						lineElement.setAttribute('x1', graphToScaledX((gdata.xmin) - xlength/2, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(gdata.xmax + (xlength/2), gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
					}
					else {
						lineElement.setAttribute('x1', graphToScaledX(gdata.xmin, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(gdata.xmax, gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
					}
					lineElement.setAttribute('id', gdata.name + '-ymajorgridline-' + m)
					lineElement.style.stroke = gdata.ymajorgridcolor
					lineElement.style.strokeWidth = gdata.ymajorgridthickness + '%';
					gdata.ymajorgridElements.push(lineElement)
					svgElement.appendChild(lineElement);
				}
				gdata.ymajorgridticks = ymajortickvalues
			}

			deleteSegments(gdata.ymajorlabelsElements)

			if (gdata.ymajorgridlabelvisibility == 'yes') {
				gdata.ymajorlabelsElements = []
				ymajortickvalues = gridtickvalues(gdata.ymin, gdata.ymax, ticks)
				scale = gdata.ymax - gdata.ymin
				expstring = scale.toExponential().toString()
				order = (expstring.slice(expstring.indexOf('e') + 1)*(-1))
				labelylocationX = gdata.axislocationX
				if (graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) < 0) {
					labelylocationX = gdata.xmin
				}
				if (graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) > 100) {
					labelylocationX = gdata.xmax
				}
				for (m = gdata.ylabelexclusionsstart; m < ymajortickvalues.length - gdata.ylabelexclusionsend; m++) {
					ticklocation = ymajortickvalues[m]

					
					var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');
					

					if(isInt(ticklocation)) {
						if (gdata.isComplexPlane == 'yes') {
							textElement.innerHTML = ticklocation + 'i'
						}
						else {
							textElement.innerHTML = ticklocation
						}
					}
					else {
						// console.log(ticklocation)
						if (Math.abs(ticklocation) < 0.01 && order > 2) {
							ticklocation = ticklocation.toExponential(order)
							// console.log(ticklocation)	
						}
						else {
							ticklocation = ticklocation.toFixed(order + 1)
							// console.log('check')
						}
						if (gdata.isComplexPlane == 'yes') {
							textElement.innerHTML = ticklocation + 'i'
						}
						else {
							textElement.innerHTML = ticklocation	
						}
						if(ticklocation == 0) {
							textElement.innerHTML = 0
						}

					}


					textElement.setAttribute('x', graphToScaledX(labelylocationX, gdata.xmin, gdata.xmax, aratio) + 0.5 + gdata.ymajorgridlabelshift + '%');
					textElement.setAttribute('y',graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + 0.5 + '%');
					textElement.setAttribute('id',name + '-yticklabel-' + m)
					textElement.style.fontSize = gdata.fontSize
					textElement.style.fontFamily = 'Calibri'
					// textElement.setAttribute('text-anchor', 'middle')
					textElement.style.fill = gdata.ymajorgridlabelcolor
					svgElement.appendChild(textElement);

					gdata.ymajorlabelsElements.push(textElement)
					
				}
			}


			deleteSegments(gdata.xmajorlabelsElements)

			if (gdata.xmajorgridlabelvisibility == 'yes') {
				gdata.xmajorlabelsElements = []
				xmajortickvalues = gridtickvalues(gdata.xmin, gdata.xmax, ticks)
				scale = gdata.xmax - gdata.xmin
				expstring = scale.toExponential().toString()
				order = (expstring.slice(expstring.indexOf('e') + 1)*(-1))
				
				labelxlocationY = gdata.axislocationY
				if (graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) < 0) {
					labelxlocationY = gdata.ymax
				}
				if (graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) > 100) {
					labelxlocationY = gdata.ymin
				}


				for (m = gdata.xlabelexclusionsstart; m < xmajortickvalues.length - gdata.xlabelexclusionsend; m++) {
					ticklocation = xmajortickvalues[m]

					var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');

					if(isInt(ticklocation)) {
						textElement.innerHTML = ticklocation
					}
					else {
						
						if (Math.abs(ticklocation) < 0.01 && order > 2) {
							ticklocation = ticklocation.toExponential(order)
							// console.log(ticklocation)
							
						}
						else {
							ticklocation = ticklocation.toFixed(order + 1)
						}
						textElement.innerHTML = ticklocation	
						
						if(ticklocation == 0) {
							textElement.innerHTML = 0
						}

					}

					transformedXval = graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) - 1
					textElement.setAttribute('x', transformedXval + '%');
					transformedYval = graphToScaledY(labelxlocationY, gdata.ymin, gdata.ymax, aratio) + 2 + gdata.xmajorgridlabelshift
					textElement.setAttribute('y', transformedYval + '%');
					textElement.setAttribute('id',name + '-xticklabel-' + m)
					textElement.style.fontSize = gdata.fontSize
					textElement.setAttribute('text-anchor', 'middle')
					if (parseFloat(order) >= 2) {
						textElement.setAttribute('transform', 'rotate(90, ' + transformedXval + ', ' + transformedYval + ')')	
					}
					textElement.style.fontFamily = 'Calibri'
					textElement.style.fill = gdata.ymajorgridlabelcolor
					svgElement.appendChild(textElement);
					
					gdata.xmajorlabelsElements.push(textElement)
					
				}
			}


			if (gdata.xaxislabelvisibility == 'yes') {
				var textElement = gdata.xaxislabelElement 
				textElement.setAttribute('x', graphToScaledX(gdata.xmax, gdata.xmin, gdata.xmax, aratio) + gdata.xaxislabelshift + '%');
				textElement.setAttribute('y',graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) + 1 + '%');
				gdata.xaxislabelElement = textElement
			}


			if (gdata.yaxislabelvisibility == 'yes') {
				var textElement = gdata.yaxislabelElement
				textElement.setAttribute('x', graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) + 0 + '%');
				textElement.setAttribute('y',graphToScaledY(gdata.ymax, gdata.ymin, gdata.ymax, aratio) - gdata.yaxislabelshift + '%');
				gdata.yaxislabelElement = textElement
				
			}


			for (var key in gdata.lineData) {
				lineElement = gdata.lineData[key][0]
				lineoptions = gdata.lineData[key][1]

				lineElement.setAttribute('x1', graphToScaledX(lineoptions.x1, gdata.xmin, gdata.xmax, aratio) + '%');
				lineElement.setAttribute('y1', graphToScaledY(lineoptions.y1, gdata.ymin, gdata.ymax, aratio) + '%');
				lineElement.setAttribute('x2', graphToScaledX(lineoptions.x2, gdata.xmin, gdata.xmax, aratio) + '%')
				lineElement.setAttribute('y2', graphToScaledY(lineoptions.y2, gdata.ymin, gdata.ymax, aratio) + '%');
			}

			for (var key in gdata.circleData) {
				circleElement = gdata.circleData[key][0]
				circleoptions = gdata.circleData[key][1]
				rx = distanceBTWgraphToSvg([0,0],[circleoptions.radius, 0], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
				ry = distanceBTWgraphToSvg([0,0],[0,circleoptions.radius], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
				circleElement.setAttribute('cx', graphToScaledX(circleoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
				circleElement.setAttribute('cy', graphToScaledY(circleoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
				circleElement.setAttribute('rx', rx + '%')
				circleElement.setAttribute('ry', ry + '%');
				
			}

			for (var key in gdata.pathData) {
				pathElement = gdata.pathData[key][0]
				pathoptions = gdata.pathData[key][1]
				// console.log(pathElement)
				pathstring = 'M'
				for (pth = 0; pth < pathoptions.points.length; pth++) {
					if (pth == 0) {
						pathstring = pathstring + graphToScaledX(pathoptions.points[pth][0], gdata.xmin, gdata.xmax, aratio) + ' ' + graphToScaledY(pathoptions.points[pth][1], gdata.ymin, gdata.ymax, aratio) + ' '
					}
					else {
						pathstring = pathstring + 'L' + graphToScaledX(pathoptions.points[pth][0], gdata.xmin, gdata.xmax, aratio) + ' ' + graphToScaledY(pathoptions.points[pth][1], gdata.ymin, gdata.ymax, aratio) + ' '
					}
				}
				pathElement.setAttribute('d', pathstring);

			}

			for (var key in gdata.ellipseData) {
				ellipseElement = gdata.ellipseData[key][0]
				ellipseoptions = gdata.ellipseData[key][1]
				rx = distanceBTWgraphToSvg([0,0],[ellipseoptions.rx, 0], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
				ry = distanceBTWgraphToSvg([0,0],[0, ellipseoptions.ry], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
				ellipseElement.setAttribute('cx', graphToScaledX(ellipseoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
				ellipseElement.setAttribute('cy', graphToScaledY(ellipseoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
				ellipseElement.setAttribute('rx', rx + '%')
				ellipseElement.setAttribute('ry', ry + '%');
				
			}

			for (var key in gdata.textData) {
				textElement = gdata.textData[key][0]
				textoptions = gdata.textData[key][1]
				textElement.setAttribute('x', graphToScaledX(textoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
				textElement.setAttribute('y', graphToScaledY(textoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			
			}

			for (var key in gdata.rectData) {
				rectElement = gdata.rectData[key][0]
				rectoptions = gdata.rectData[key][1]
				
				
				rx = distanceBTWgraphToSvg([0,0],[rectoptions.w, 0], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
				ry = distanceBTWgraphToSvg([0,0],[0, rectoptions.h], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
				
				rectElement.setAttribute('x', graphToScaledX(rectoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
				rectElement.setAttribute('y', graphToScaledY(rectoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
				rectElement.setAttribute('width', rx + '%')
				rectElement.setAttribute('height', ry + '%');
			}			

			for (var key in gdata.pointData) {
				pointElement = gdata.pointData[key][0]
				pointoptions = gdata.pointData[key][1]
				
				
				pointElement.setAttribute('cx', graphToScaledX(pointoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
				pointElement.setAttribute('cy', graphToScaledY(pointoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			}			


		}

		function addGraph(parentdiv, name, gdata) {
			gdata = gdata || {}

			gdata.name = name || 'graph' + Math.random().toString()

			if (gdata.axislocationX != 0) {
				gdata.axislocationX = gdata.axislocationX || 0
			}
			else {
				gdata.axislocationX = 0
			}
			if (gdata.axislocationY != 0) {
				gdata.axislocationY = gdata.axislocationY || 0
			}
			else {
				gdata.axislocationY = 0
			}
			if (gdata.xmin != 0) {
				gdata.xmin = gdata.xmin || -1
			}
			else {
				gdata.xmin = 0
			}
			if (gdata.xmax != 0) {
				gdata.xmax = gdata.xmax || -1
			}
			else {
				gdata.xmax = 0
			}
			if (gdata.ymin != 0) {
				gdata.ymin = gdata.ymin || -1
			}
			else {
				gdata.ymin = 0
			}
			if (gdata.ymax != 0) {
				gdata.ymax = gdata.ymax || -1
			}
			else {
				gdata.ymax = 0
			}

			gdata.unitAspectRatio = gdata.unitAspectRatio || 'no'
			gdata.fixAxis = gdata.fixAxis || 'yaxis'
			gdata.fixAxisStretchCentrally = gdata.fixAxisStretchCentrally || 'no'


			gdata.xaxisvisibility = gdata.xaxisvisibility || 'yes'
			gdata.yaxisvisibility = gdata.yaxisvisibility || 'yes'

			gdata.xaxislabelvisibility = gdata.xaxislabelvisibility || 'yes' 
			gdata.yaxislabelvisibility = gdata.yaxislabelvisibility || 'yes'
			
			gdata.xmajorgridlinesvisibility = gdata.xmajorgridlinesvisibility || 'yes'
			gdata.ymajorgridlinesvisibility = gdata.ymajorgridlinesvisibility || 'yes'

			var svgElement = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
			svgElement.setAttribute('height',"100%");
			svgElement.setAttribute('width', '100%');
			svgElement.setAttribute('viewBox',"0 0 100 100")
			// svgElement.setAttribute('preserveAspectRatio',"none")
			svgElement.setAttribute('id', name)
			svgElement.style.position = "absolute";
			svgElement.style.left = '0%'
			svgElement.style.top = '0%'
			parentdiv.appendChild(svgElement)
			gdata.svgElement = svgElement
			gdata.parentElement = parentdiv

			gdata.fontSize = gdata.fontSize || 5

			gdata.gridlinenumber = gdata.gridlinenumber || 10
			ticks = gdata.gridlinenumber

			gdata.parentW = parentdiv.offsetWidth
			gdata.parentH = parentdiv.offsetHeight

			aratio = parentdiv.offsetWidth/parentdiv.offsetHeight

			if (gdata.unitAspectRatio == 'yes') {
				if (gdata.fixAxis == 'yaxis') {
					if (gdata.fixAxisStretchCentrally == 'yes') {
						centre = (gdata.xmax + gdata.xmin)/2
						gdata.xmin = centre - ((gdata.ymax - gdata.ymin)*aratio/2)
						gdata.xmax = centre + ((gdata.ymax - gdata.ymin)*aratio/2)
					}
					else {
						gdata.xmax = gdata.xmin + (gdata.ymax - gdata.ymin)*aratio
					}
					
				}
				else {
					if (gdata.fixAxisStretchCentrally == 'yes') {
						centre = (gdata.ymax + gdata.ymin)/2
						gdata.ymin = centre - ((gdata.xmax - gdata.xmin)*aratio/2)
						gdata.ymax = centre + ((gdata.xmax - gdata.xmin)*aratio/2)
					}
					else {
						gdata.ymax = gdata.ymin + (gdata.xmax - gdata.xmin)*aratio	
					}
					
				}
			}



			if (darkmode) {
				gdata.yaxiscolor = gdata.yaxiscolor || 'hsla(0, 100%, 100%, 1)'			
				gdata.xaxiscolor = gdata.xaxiscolor || 'hsla(0, 100%, 100%, 1)'			
				gdata.xmajorgridlabelcolor = gdata.xmajorgridlabelcolor || 'hsla(0, 100%, 100%, 1)'
				gdata.ymajorgridlabelcolor = gdata.ymajorgridlabelcolor || 'hsla(0, 100%, 100%, 1)'
				gdata.xmajorgridcolor = gdata.xmajorgridcolor || 'hsla(0, 100%, 100%, 1)'
				gdata.ymajorgridcolor = gdata.ymajorgridcolor || 'hsla(0, 100%, 100%, 1)'
			}

			gdata.yaxisthickness = gdata.yaxisthickness || 0.5
			gdata.yaxiscolor = gdata.yaxiscolor || 'hsla(0, 50%, 0%, 1)'


			if (gdata.yaxisvisibility == 'yes') {
				var lineElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
				lineElement.setAttribute('x1', graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) + '%');
				lineElement.setAttribute('y1', graphToScaledY(gdata.ymax, gdata.ymin, gdata.ymax, aratio) + '%');
				lineElement.setAttribute('vector-effect','non-scaling-stroke');
				lineElement.setAttribute('x2', graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) + '%')
				lineElement.setAttribute('y2', graphToScaledY(gdata.ymin, gdata.ymin, gdata.ymax, aratio) + '%');
				lineElement.setAttribute('id', gdata.name + '-yaxis')
				lineElement.style.stroke = gdata.yaxiscolor
				lineElement.style.strokeWidth = gdata.yaxisthickness + '%';
				gdata.yaxisElement = lineElement
				svgElement.appendChild(lineElement);
			}

			gdata.xaxisthickness = gdata.xaxisthickness || 0.5
			gdata.xaxiscolor = gdata.xaxiscolor || 'hsla(0, 50%, 0%, 1)'

			
			if (gdata.xaxisvisibility == 'yes') {
				var lineElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
				lineElement.setAttribute('x1', graphToScaledX(gdata.xmin, gdata.xmin, gdata.xmax, aratio) + '%');
				lineElement.setAttribute('y1', graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) + '%');
				lineElement.setAttribute('vector-effect','non-scaling-stroke');
				lineElement.setAttribute('x2', graphToScaledX(gdata.xmax, gdata.xmin, gdata.xmax, aratio) + '%')
				lineElement.setAttribute('y2', graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) + '%');
				lineElement.setAttribute('id', gdata.name + '-xaxis')
				lineElement.style.stroke = gdata.xaxiscolor
				lineElement.style.strokeWidth = gdata.xaxisthickness + '%';
				gdata.xaxisElement = lineElement
				svgElement.appendChild(lineElement);
			}


			gdata.xmajorgridcolor = gdata.xmajorgridcolor || 'hsla(190, 0%, 50%, 1)'
			gdata.xmajorgridthickness = gdata.xmajorgridthickness || 0.3

			gdata.xmajorgridlinesextension = gdata.xmajorgridlinesextension || 'yes'
			gdata.ymajorgridlinesextension = gdata.ymajorgridlinesextension || 'yes'
			
			if (gdata.xmajorgridlinesvisibility == 'yes') {
				xmajortickvalues = gridtickvalues(gdata.xmin, gdata.xmax, ticks)
				gdata.xmajorgridElements = []
				for (m = 0; m < xmajortickvalues.length; m++) {
					ticklocation = xmajortickvalues[m]
					var lineElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
					ylength = (gdata.ymax - gdata.ymin)
					if (gdata.xmajorgridlinesextension == 'yes') {
						lineElement.setAttribute('x1', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(gdata.ymin - (ylength)/2, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(gdata.ymax + (ylength)/2, gdata.ymin, gdata.ymax, aratio) + '%');
						
					}
					else {
						lineElement.setAttribute('x1', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(gdata.ymin, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(gdata.ymax, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('id', gdata.name + '-xmajorgridline-' + m)
					}
					lineElement.style.stroke = gdata.xmajorgridcolor
					lineElement.style.strokeWidth = gdata.xmajorgridthickness + '%';
					gdata.xmajorgridElements.push(lineElement)
					svgElement.appendChild(lineElement);
				}
				gdata.xmajorgridticks = xmajortickvalues
			}

			gdata.ymajorgridcolor = gdata.ymajorgridcolor || 'hsla(190, 0%, 50%, 1)'
			gdata.ymajorgridthickness = gdata.ymajorgridthickness || 0.3


			if (gdata.ymajorgridlinesvisibility == 'yes') {
				ymajortickvalues = gridtickvalues(gdata.ymin, gdata.ymax, ticks)
				gdata.ymajorgridElements = []
				for (m = 0; m < ymajortickvalues.length; m++) {
					ticklocation = ymajortickvalues[m]
					var lineElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
					xlength = (gdata.xmax - gdata.xmin)
					if (gdata.ymajorgridlinesextension == 'yes') {
						lineElement.setAttribute('x1', graphToScaledX((gdata.xmin) - xlength/2, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(gdata.xmax + (xlength/2), gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
					}
					else {
						lineElement.setAttribute('x1', graphToScaledX(gdata.xmin, gdata.xmin, gdata.xmax, aratio) + '%');
						lineElement.setAttribute('y1', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
						lineElement.setAttribute('vector-effect','non-scaling-stroke');
						lineElement.setAttribute('x2', graphToScaledX(gdata.xmax, gdata.xmin, gdata.xmax, aratio) + '%')
						lineElement.setAttribute('y2', graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + '%');
					}
					lineElement.setAttribute('id', gdata.name + '-ymajorgridline-' + m)
					lineElement.style.stroke = gdata.ymajorgridcolor
					lineElement.style.strokeWidth = gdata.ymajorgridthickness + '%';
					gdata.ymajorgridElements.push(lineElement)
					svgElement.appendChild(lineElement);
				}
				gdata.ymajorgridticks = ymajortickvalues
			}

			

			gdata.ymajorgridlabelvisibility = gdata.ymajorgridlabelvisibility || 'yes'
			gdata.ymajorgridlabelcolor = gdata.ymajorgridlabelcolor || 'hsla(190, 0%, 50%, 1)'


			gdata.ymajorgridlabelshift = gdata.ymajorgridlabelshift || 0.1
			gdata.xmajorgridlabelshift = gdata.xmajorgridlabelshift || 0.1

			gdata.xmajorgridlabelvisibility = gdata.xmajorgridlabelvisibility || 'yes'
			gdata.xmajorgridlabelcolor = gdata.xmajorgridlabelcolor || 'hsla(190, 0%, 50%, 1)'



			gdata.xlabelexclusionsstart = gdata.xlabelexclusionsstart || 0
			gdata.xlabelexclusionsend = gdata.xlabelexclusionsend || 0

			gdata.ylabelexclusionsstart = gdata.ylabelexclusionsstart || 0
			gdata.ylabelexclusionsend = gdata.ylabelexclusionsend || 0


			gdata.isComplexPlane = gdata.isComplexPlane || 'no'


			if (gdata.ymajorgridlabelvisibility == 'yes') {
				gdata.ymajorlabelsElements = []
				ymajortickvalues = gridtickvalues(gdata.ymin, gdata.ymax, ticks)
				labelylocationX = gdata.axislocationX
				if (graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) < 0) {
					labelylocationX = gdata.xmin
				}
				if (graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) > 100) {
					labelylocationX = gdata.xmax
				}
				for (m = gdata.ylabelexclusionsstart; m < ymajortickvalues.length - gdata.ylabelexclusionsend; m++) {
					ticklocation = ymajortickvalues[m]

					var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');
					

					if(isInt(ticklocation)) {
						if (gdata.isComplexPlane == 'yes') {
							textElement.innerHTML = ticklocation + 'i'
						}
					}
					else {
						expstring = ticklocation.toExponential().toString()
						order = (expstring.slice(expstring
							.indexOf('e') + 1)*(-1))
						if (parseFloat(order) < -1) {
							ticklocation = ticklocation.toExponential(0)	
						}
						else {
							ticklocation = ticklocation.toFixed(2)
						}
						// ticklocation = ticklocation.toExponential(0)
						textElement.innerHTML = ticklocation
						if(ticklocation == 0) {
							textElement.innerHTML = 0
						}
						if (gdata.isComplexPlane == 'yes') {
							textElement.innerHTML = ticklocation + 'i'
						}

					}


					textElement.setAttribute('x', graphToScaledX(labelylocationX, gdata.xmin, gdata.xmax, aratio) + 0.5 + gdata.ymajorgridlabelshift + '%');
					textElement.setAttribute('y',graphToScaledY(ticklocation, gdata.ymin, gdata.ymax, aratio) + 0.5 + '%');
					textElement.setAttribute('id',name + '-yticklabel-' + m)
					textElement.style.fontSize = gdata.fontSize
					textElement.style.fontFamily = 'Calibri'
					textElement.style.fill = gdata.ymajorgridlabelcolor
					svgElement.appendChild(textElement);

					gdata.ymajorlabelsElements.push(textElement)
					
				}
			}


			if (gdata.xmajorgridlabelvisibility == 'yes') {
				gdata.xmajorlabelsElements = []
				xmajortickvalues = gridtickvalues(gdata.xmin, gdata.xmax, ticks)
				labelxlocationY = gdata.axislocationY
				if (graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) < 0) {
					labelxlocationY = gdata.ymin
				}
				if (graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) > 100) {
					labelxlocationY = gdata.ymax
				}


				for (m = gdata.xlabelexclusionsstart; m < xmajortickvalues.length - gdata.xlabelexclusionsend; m++) {
					ticklocation = xmajortickvalues[m]

					var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');

					if(isInt(ticklocation)) {
						textElement.innerHTML = ticklocation
					}
					else {

						expstring = ticklocation.toExponential().toString()
						order = (expstring.slice(expstring.indexOf('e') + 1)*(-1))
						if (parseFloat(order) < -1) {
							ticklocation = ticklocation.toExponential(0)	
						}
						else {
							ticklocation = ticklocation.toFixed(2)
						}
						textElement.innerHTML = ticklocation
						if(ticklocation == 0) {
							textElement.innerHTML = 0
						}

					}

					textElement.setAttribute('x', graphToScaledX(ticklocation, gdata.xmin, gdata.xmax, aratio) - 1 + '%');
					textElement.setAttribute('y',graphToScaledY(labelxlocationY, gdata.ymin, gdata.ymax, aratio) + 2 + gdata.xmajorgridlabelshift + '%');
					textElement.setAttribute('id',name + '-xticklabel-' + m)
					textElement.style.fontSize = gdata.fontSize
					textElement.style.fontFamily = 'Calibri'
					textElement.style.fill = gdata.ymajorgridlabelcolor
					svgElement.appendChild(textElement);
					
					gdata.xmajorlabelsElements.push(textElement)
					
				}
			}


			gdata.xaxislabel = gdata.xaxislabel || 'x axis'
			gdata.yaxislabel = gdata.yaxislabel || 'y axis'

			gdata.xaxislabelshift = gdata.xaxislabelshift || 2
			gdata.yaxislabelshift = gdata.yaxislabelshift || 2

			if (gdata.xaxislabelvisibility == 'yes') {
				var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');
				textElement.innerHTML = gdata.xaxislabel 
				textElement.setAttribute('x', graphToScaledX(gdata.xmax, gdata.xmin, gdata.xmax, aratio) + gdata.xaxislabelshift + '%');
				textElement.setAttribute('y',graphToScaledY(gdata.axislocationY, gdata.ymin, gdata.ymax, aratio) + 1 + '%');
				textElement.setAttribute('id',name + '-xaxislabel')
				textElement.style.fontSize = gdata.fontSize
				textElement.style.fontFamily = 'Calibri'
				
				svgElement.appendChild(textElement);
				gdata.xaxislabelElement = textElement
				
			}


			if (gdata.yaxislabelvisibility == 'yes') {
				var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');
				textElement.innerHTML = gdata.yaxislabel 
				textElement.setAttribute('x', graphToScaledX(gdata.axislocationX, gdata.xmin, gdata.xmax, aratio) + 0 + '%');
				textElement.setAttribute('y',graphToScaledY(gdata.ymax, gdata.ymin, gdata.ymax, aratio) - gdata.yaxislabelshift + '%');
				textElement.setAttribute('id',name + '-yaxislabel')
				textElement.style.fontSize = gdata.fontSize
				textElement.style.fontFamily = 'Calibri'
				
				svgElement.appendChild(textElement);
				gdata.yaxislabelElement = textElement
				
			}

			gdata.lineData = {}
			gdata.circleData = {}
			gdata.pointData = {}
			gdata.ellipseData = {}
			gdata.rectData = {}
			gdata.textData = {}
			gdata.pathData = {}

			gdata.aspectratio = aratio



			graphData[name] = gdata
			return JSON.parse(JSON.stringify(gdata));
		}

		function getGraphCursorLocation(cursorpercent, graphname) {
			gdata = graphData[graphname]

			graphEl = document.getElementById(gdata.name)

			valx = svgToGraphX(cursorpercent[0], gdata.xmin, gdata.xmax, gdata.aspectratio)
			valy = svgToGraphY(cursorpercent[1], gdata.ymin, gdata.ymax, gdata.aspectratio)

			return [valx, valy]
		}


		function addLine(graphname, linename, lineoptions) {
			gdata = graphData[graphname]
			lineoptions = lineoptions || {}

			aratio = gdata.aspectratio

			lineoptions.x1 = parseFloat(lineoptions.x1.toString() || 0)
			lineoptions.y1 = parseFloat(lineoptions.y1.toString() || 0)
			lineoptions.x2 = parseFloat(lineoptions.x2.toString() || 0.5)
			lineoptions.y2 = parseFloat(lineoptions.y2.toString() || 0.5)
			lineoptions.name = linename || uid

			lineoptions.strokedasharray = lineoptions.strokedasharray || ""

			// console.log((0).toString() || 0.5)

			lineoptions.strokewidth = lineoptions.strokewidth || 1
			lineoptions.linecolor = lineoptions.linecolor || 'hsla(190, 100%, 50%, 1)'

			var lineElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
			lineElement.setAttribute('x1', graphToScaledX(lineoptions.x1, gdata.xmin, gdata.xmax, aratio) + '%');
			lineElement.setAttribute('y1', graphToScaledY(lineoptions.y1, gdata.ymin, gdata.ymax, aratio) + '%');
			lineElement.setAttribute('x2', graphToScaledX(lineoptions.x2, gdata.xmin, gdata.xmax, aratio) + '%')
			lineElement.setAttribute('y2', graphToScaledY(lineoptions.y2, gdata.ymin, gdata.ymax, aratio) + '%');
			lineElement.setAttribute('stroke-dasharray', lineoptions.strokedasharray);
			
			lineElement.setAttribute('id', graphname + '-line-' + linename)
			uid = uid + 1
			lineElement.setAttribute('vector-effect','non-scaling-stroke');
			lineElement.style.stroke = lineoptions.linecolor
			lineElement.style.strokeWidth = lineoptions.strokewidth + '%';
			gdata.svgElement.appendChild(lineElement);

			graphData[graphname].lineData[linename] = [lineElement, lineoptions]
			return [lineElement, lineoptions]
		}

		function addPath(graphname, pathname, pathoptions) {
			gdata = graphData[graphname]
			pathoptions = pathoptions || {}

			aratio = gdata.aspectratio

			pathoptions.points = pathoptions.points || [[0, 1], [1, 0]]

			pathstring = 'M'

			for (pth = 0; pth < pathoptions.points.length; pth++) {
				xpart = graphToScaledX(pathoptions.points[pth][0], gdata.xmin, gdata.xmax, aratio)
				ypart = graphToScaledY(pathoptions.points[pth][1], gdata.ymin, gdata.ymax, aratio)
				if (pth == 0) {
					if (isNaN(xpart) == false && isNaN(ypart) == false) {
						pathstring = pathstring + xpart + ' ' + ypart + ' '	
					}
				}
				else {
					if (isNaN(xpart) == false && isNaN(ypart) == false) {
						pathstring = pathstring + 'L' + xpart + ' ' + ypart + ' '	
					}
					
				}
				
			}


			// pathstring = 'M20 20 L10 10 L6 50 L9 67' 

			// console.log(pathstring)

			pathoptions.name = pathname || uid
			// console.log((0).toString() || 0.5)

			pathoptions.strokewidth = pathoptions.strokewidth || 1
			pathoptions.pathcolor = pathoptions.pathcolor || 'hsla(190, 100%, 50%, 1)'

			var pathElement = document.createElementNS("http://www.w3.org/2000/svg", 'path');
			pathElement.setAttribute('d', pathstring);
			pathElement.setAttribute('id', graphname + '-path-' + pathname)
			uid = uid + 1
			pathElement.style.stroke = pathoptions.pathcolor
			pathElement.style.fill = 'none'
			pathElement.style.strokeWidth = pathoptions.strokewidth + '%';
			gdata.svgElement.appendChild(pathElement);

			graphData[graphname].pathData[pathname] = [pathElement, pathoptions]
			return [pathElement, pathoptions]
		}

		function updatePath(graphname, pathname, npathpoints) {

			gdata = graphData[graphname]
			aratio = gdata.aspectratio

			pathoptions = gdata.pathData[pathname][1]
			pathElement = gdata.pathData[pathname][0]

			pathoptions.points = npathpoints || pathoptions.points

			pathstring = 'M'

			for (pth = 0; pth < pathoptions.points.length; pth++) {
				if (pth == 0) {
					pathstring = pathstring + graphToScaledX(pathoptions.points[pth][0], gdata.xmin, gdata.xmax, aratio) + ' ' + graphToScaledY(pathoptions.points[pth][1], gdata.ymin, gdata.ymax, aratio) + ' '
				}
				else {
					pathstring = pathstring + 'L' + graphToScaledX(pathoptions.points[pth][0], gdata.xmin, gdata.xmax, aratio) + ' ' + graphToScaledY(pathoptions.points[pth][1], gdata.ymin, gdata.ymax, aratio) + ' '
				}
				
			}

			pathElement.setAttribute('d', pathstring);
			
			graphData[graphname].pathData[pathname] = [pathElement, pathoptions]

			return [pathElement, pathoptions]
		}


		function updateLine(graphname, linename, linevalues) {

			gdata = graphData[graphname]
			aratio = gdata.aspectratio

			lineoptions = gdata.lineData[linename][1]
			lineElement = gdata.lineData[linename][0]
			
			if (linevalues.x1 != 0) {
				lineoptions.x1 = linevalues.x1 || lineoptions.x1	
			}
			else {
				lineoptions.x1 = linevalues.x1
			}


			if (linevalues.y1 != 0) {
				lineoptions.y1 = linevalues.y1 || lineoptions.y1	
			}
			else {
				lineoptions.y1 = linevalues.y1
			}


			if (linevalues.x2 != 0) {
				lineoptions.x2 = linevalues.x2 || lineoptions.x2	
			}
			else {
				lineoptions.x2 = linevalues.x2
			}


			if (linevalues.y2 != 0) {
				lineoptions.y2 = linevalues.y2 || lineoptions.y2	
			}
			else {
				lineoptions.y2 = linevalues.y2
			}

			lineElement.setAttribute('x1', graphToScaledX(lineoptions.x1, gdata.xmin, gdata.xmax, aratio) + '%');
			lineElement.setAttribute('y1', graphToScaledY(lineoptions.y1, gdata.ymin, gdata.ymax, aratio) + '%');
			lineElement.setAttribute('x2', graphToScaledX(lineoptions.x2, gdata.xmin, gdata.xmax, aratio) + '%')
			lineElement.setAttribute('y2', graphToScaledY(lineoptions.y2, gdata.ymin, gdata.ymax, aratio) + '%');
			
			
			graphData[graphname].lineData[linename] = [lineElement, lineoptions]
		}


		function distanceBTWgraphToSvg(p1, p2, xmin, xmax, ymin, ymax, aspectratio) {
			pt1 = [graphToScaledX(p1[0], xmin, xmax, aspectratio), graphToScaledY(p1[1], ymin, ymax, aspectratio)]
			pt2 = [graphToScaledX(p2[0], xmin, xmax, aspectratio), graphToScaledY(p2[1], ymin, ymax, aspectratio)]

			return Math.pow(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2), 0.5)
		}


		function addCircle(graphname, circlename, circleoptions) {
			gdata = graphData[graphname]
			circleoptions = circleoptions || {}
			aratio = gdata.aspectratio

			circleoptions.x = circleoptions.x || 0.3
			circleoptions.y = circleoptions.y || 0.3
			circleoptions.radius = circleoptions.radius || 0.1
			circleoptions.name = circlename || uid

			circleoptions.stroke = circleoptions.stroke || 'hsla(190, 100%, 50%, 0.5)'
			circleoptions.strokewidth = circleoptions.strokewidth || 0.1
			

			circleoptions.circlecolor = circleoptions.circlecolor || 'hsla(190, 100%, 50%, 1)'

			rx = distanceBTWgraphToSvg([0,0],[circleoptions.radius, 0], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			ry = distanceBTWgraphToSvg([0,0],[0, circleoptions.radius], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			
			var circleElement = document.createElementNS("http://www.w3.org/2000/svg", 'ellipse');
			circleElement.setAttribute('cx', graphToScaledX(circleoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			circleElement.setAttribute('cy', graphToScaledY(circleoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			circleElement.setAttribute('rx', rx + '%')
			circleElement.setAttribute('ry', ry + '%');
			circleElement.setAttribute('id', graphname + '-circle-' + circlename)
			uid = uid + 1
			circleElement.setAttribute('vector-effect','non-scaling-stroke');
			circleElement.style.fill = circleoptions.circlecolor
			circleElement.style.strokeWidth = circleoptions.strokewidth + '%';
			circleElement.style.stroke = circleoptions.stroke;
			gdata.svgElement.appendChild(circleElement);

			graphData[graphname].circleData[circlename] = [circleElement, circleoptions]
		}

		function addEllipse(graphname, ellipsename, ellipseoptions) {
			gdata = graphData[graphname]

			aratio = gdata.aspectratio

			ellipseoptions = ellipseoptions || {}

			ellipseoptions.x = parseFloat(ellipseoptions.x.toString() || 0)
			ellipseoptions.y = parseFloat(ellipseoptions.y.toString() || 0)
			ellipseoptions.rx = parseFloat(ellipseoptions.rx.toString() || 0.3)
			ellipseoptions.ry = parseFloat(ellipseoptions.ry.toString() || 8)
			ellipseoptions.name = ellipsename || uid

			ellipseoptions.stroke = ellipseoptions.stroke || 'hsla(190, 100%, 50%, 0.5)'
			ellipseoptions.strokewidth = ellipseoptions.strokewidth || 0.1
			
			ellipseoptions.ellipsecolor = ellipseoptions.ellipsecolor || 'hsla(190, 100%, 50%, 1)'

			rx = distanceBTWgraphToSvg([0,0],[ellipseoptions.rx, 0], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			ry = distanceBTWgraphToSvg([0,0],[0, ellipseoptions.ry], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			
			var ellipseElement = document.createElementNS("http://www.w3.org/2000/svg", 'ellipse');
			ellipseElement.setAttribute('cx', graphToScaledX(ellipseoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			ellipseElement.setAttribute('cy', graphToScaledY(ellipseoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			ellipseElement.setAttribute('rx', rx + '%')
			ellipseElement.setAttribute('ry', ry + '%');
			ellipseElement.setAttribute('id', graphname + '-ellipse-' + ellipsename)
			uid = uid + 1
			ellipseElement.setAttribute('vector-effect','non-scaling-stroke');
			ellipseElement.style.fill = ellipseoptions.ellipsecolor
			ellipseElement.style.strokeWidth = ellipseoptions.strokewidth + '%';
			ellipseElement.style.stroke = ellipseoptions.stroke;
			gdata.svgElement.appendChild(ellipseElement);

			graphData[graphname].ellipseData[ellipsename] = [ellipseElement, ellipseoptions]
		}

		function addText(graphname, textname, textoptions) {
			gdata = graphData[graphname]
			textoptions = textoptions || {}

			aratio = gdata.aspectratio

			textoptions.x = parseFloat(textoptions.x.toString() || 0)
			textoptions.y = parseFloat(textoptions.y.toString() || 0)
			textoptions.text = textoptions.text || ''
			textoptions.name = textname || uid

			textoptions.textAlign = textoptions.textAlign || 'left'
			textoptions.fontSize = textoptions.fontSize || 12
			
			textoptions.textcolor = textoptions.textcolor || 'hsla(190, 100%, 0%, 1)'
			
			var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');
			textElement.setAttribute('x', graphToScaledX(textoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			textElement.setAttribute('y', graphToScaledY(textoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			textElement.setAttribute('id', graphname + '-text-' + textname)
			uid = uid + 1
			textElement.setAttribute('vector-effect','non-scaling-stroke');
			textElement.style.fill = textoptions.textcolor
			textElement.innerHTML = textoptions.text
			textElement.style.fontFamily = 'Calibri'
			textElement.style.fontSize = textoptions.fontSize;
			if (textoptions.textAlign == 'center') {
				textElement.setAttribute('text-anchor','middle')
			}
			gdata.svgElement.appendChild(textElement);

			graphData[graphname].textData[textname] = [textElement, textoptions]
			return [textElement, textoptions]
		}

		function updateText(graphname, textname, updatetext) {
			gdata = graphData[graphname]

			aratio = gdata.aspectratio

			textoptions = gdata.textData[textname][1]
			textElement = gdata.textData[textname][0]

			textoptions.text = updatetext.text || textoptions.text
			textoptions.x = updatetext.x || textoptions.x
			textoptions.y = updatetext.y || textoptions.y
			textoptions.name = textname || uid

			textElement.innerHTML = textoptions.text
			textElement.setAttribute('x', graphToScaledX(textoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			textElement.setAttribute('y', graphToScaledY(textoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			
			
			graphData[graphname].textData[textname] = [textElement, textoptions]
			return [textElement, textoptions]
		}

		function addRectangle(graphname, rectname, rectoptions) {
			gdata = graphData[graphname]
			aratio = gdata.aspectratio
			rectoptions = rectoptions || {}

			rectoptions.x = parseFloat(rectoptions.x.toString() || 0)
			rectoptions.y = parseFloat(rectoptions.y.toString() || 0)
			rectoptions.w = parseFloat(rectoptions.w.toString() || 1)
			rectoptions.h = parseFloat(rectoptions.h.toString() || 1)
			rectoptions.name = rectname || uid

			rectoptions.stroke = rectoptions.stroke || 'hsla(190, 100%, 50%, 0.5)'
			rectoptions.strokewidth = rectoptions.strokewidth || 0.1
			
			rectoptions.rectcolor = rectoptions.rectcolor || 'hsla(190, 100%, 50%, 1)'

			rx = distanceBTWgraphToSvg([0,0],[rectoptions.w, 0], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			ry = distanceBTWgraphToSvg([0,0],[0, rectoptions.h], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			
			var rectElement = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
			rectElement.setAttribute('x', graphToScaledX(rectoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			rectElement.setAttribute('y', graphToScaledY(rectoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			rectElement.setAttribute('width', rx + '%')
			rectElement.setAttribute('height', ry + '%');
			rectElement.setAttribute('id', graphname + '-rect-' + rectname)
			uid = uid + 1
			rectElement.setAttribute('vector-effect','non-scaling-stroke');
			rectElement.style.fill = rectoptions.rectcolor
			rectElement.style.strokeWidth = rectoptions.strokewidth + '%';
			rectElement.style.stroke = rectoptions.stroke;
			gdata.svgElement.appendChild(rectElement);

			graphData[graphname].rectData[rectname] = [rectElement, rectoptions]
		}


		function updateRectangle(graphname, rectname, rectvalueupdate) {
			gdata = graphData[graphname]
			rectoptions = gdata.rectData[rectname][1]
			rectElement = gdata.rectData[rectname][0]
			aratio = gdata.aspectratio

			if (rectvalueupdate.x != 0) {
				rectoptions.x = rectvalueupdate.x || rectoptions.x	
			}
			else {
				rectoptions.x = rectvalueupdate.x
			}


			if (rectvalueupdate.y != 0) {
				rectoptions.y = rectvalueupdate.y || rectoptions.y	
			}
			else {
				rectoptions.y = rectvalueupdate.y
			}


			if (rectvalueupdate.w != 0) {
				rectoptions.w = rectvalueupdate.w || rectoptions.w	
			}
			else {
				rectoptions.w = rectvalueupdate.w
			}


			if (rectvalueupdate.h != 0) {
				rectoptions.h = rectvalueupdate.h || rectoptions.h	
			}
			else {
				rectoptions.h = rectvalueupdate.h
			}
			
			rectoptions.stroke = rectvalueupdate.stroke || rectoptions.stroke
			rectoptions.strokewidth = rectvalueupdate.strokewidth || rectoptions.strokewidth
			
			rectoptions.rectcolor = rectvalueupdate.rectcolor || rectoptions.rectcolor

			rx = distanceBTWgraphToSvg([0,0],[rectoptions.w, 0], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			ry = distanceBTWgraphToSvg([0,0],[0, rectoptions.h], gdata.xmin, gdata.xmax, gdata.ymin, gdata.ymax, aratio)
			
			rectElement.setAttribute('x', graphToScaledX(rectoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			rectElement.setAttribute('y', graphToScaledY(rectoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			rectElement.setAttribute('width', rx + '%')
			rectElement.setAttribute('height', ry + '%');
			rectElement.style.fill = rectoptions.rectcolor
			rectElement.style.strokeWidth = rectoptions.strokewidth + '%';
			rectElement.style.stroke = rectoptions.stroke;
			
			graphData[graphname].rectData[rectname] = [rectElement, rectoptions]
		}




		function addPoint(graphname, pointname, pointoptions) {
			gdata = graphData[graphname]
			aratio = gdata.aspectratio

			pointoptions = pointoptions || {}

			if (pointoptions.x != 0) {
				pointoptions.x = pointoptions.x || 0.3	
			}
			if (pointoptions.y != 0) {
				pointoptions.y = pointoptions.y || 0.3	
			}
			// pointoptions.y = pointoptions.y || 0.3
			pointoptions.pointsize = pointoptions.pointsize || 0.7
			pointoptions.name = pointname || uid

			pointoptions.pointcolor = pointoptions.pointcolor || 'hsla(190, 100%, 50%, 1)'
			
			var pointElement = document.createElementNS("http://www.w3.org/2000/svg", 'ellipse');
			pointElement.setAttribute('cx', graphToScaledX(pointoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			pointElement.setAttribute('cy', graphToScaledY(pointoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');
			pointElement.setAttribute('rx', pointoptions.pointsize + '%')
			pointElement.setAttribute('ry', pointoptions.pointsize + '%');
			pointElement.setAttribute('id', graphname + '-point-' + pointname)
			uid = uid + 1
			pointElement.setAttribute('vector-effect','non-scaling-stroke');
			pointElement.style.fill = pointoptions.pointcolor
			gdata.svgElement.appendChild(pointElement);

			graphData[graphname].pointData[pointname] = [pointElement, pointoptions]
			return [pointElement, pointoptions]
		}

		function updatePoint(graphname, pointname, xvalue, yvalue) {
			pointElement = document.getElementById(graphname + '-point-' + pointname)
			
			gdata = graphData[graphname]
			aratio = gdata.aspectratio

			pointoptions = graphData[graphname].pointData[pointname][1]

			pointoptions.x = xvalue
			pointoptions.y = yvalue
			
			
			pointElement.setAttribute('cx', graphToScaledX(pointoptions.x, gdata.xmin, gdata.xmax, aratio) + '%');
			pointElement.setAttribute('cy', graphToScaledY(pointoptions.y, gdata.ymin, gdata.ymax, aratio) + '%');

			graphData[graphname].pointData[pointname] = [pointElement, pointoptions]
		}

		function removePoint(graphname, pointname) {
			pointElement = document.getElementById(graphname + '-point-' + pointname)
			
			pointElement.outerHTML = "";
			delete graphData[graphname].pointData[pointname]
		}


		graphData = {}

		darkmode = false
			
		uid = 0
		
		function generateTimeArray(start, stop, sampling) {
			samplingdelta = (stop - start)/(sampling - 1)
			returnarray = []
			for (m = 0; m < sampling; m = m + 1) {
				returnarray.push(start + (m*samplingdelta))
			}
			return returnarray
		}

		function uniformDist(low, high, sampling) {
			returnarray = []
			for (n = 0; n < sampling; n++) {
				value = low + ((high - low)*Math.random())
				returnarray.push(value)
			}
			return returnarray
		}

		function normalDist(mean, deviation, sampling) {
			u1 = uniformDist(0, 1, sampling)
			u2 = uniformDist(0, 1, sampling)
			
			returnarray = []
			for (n = 0; n < sampling; n++) {
				value = Math.sqrt(-2*Math.log(u1[n]))*Math.cos(2*Math.PI*u2[n])
				returnarray.push(value)
			}
			return returnarray
		}


		// time = generateTimeArray(-2, 3, 8192)

		// ntime = []

		function gravitationalWave(t) {
			
			A = Math.random()
			B = Math.random()
			C = Math.random()
			D = 100 + Math.random()
			E = Math.random()

			noise = normalDist(-0.5, 0.5, 8192)

			y = []
			ynoise = []

			offset = 0

			// console.log(B)

			for (k = 0; k < t.length; k++) {
				ctime = t[k]
				val = A*Math.exp(((-1)*Math.pow(ctime - offset - B, 2))/(Math.pow(C, 2)))*Math.sin(D*ctime + E)
				if (ctime > -0.5 && ctime < 0.12) {
					y.push(val)
					ntime.push(ctime)
				}
				ynoise.push(val + noise[k])
			}

			return [y, ynoise]
		}


		// gWave = gravitationalWave(time)


		function plotF(maingraph, plotname, xvalues, yvalues, color, stkwidth) {
			values = []
			if (xvalues.length == yvalues.length) {
				for (m = 0; m < xvalues.length; m++) {
					values.push([xvalues[m], yvalues[m]])
				}
			}
			else {
				console.log('xvalue array length of ' + xvalues.length + ' doesnt match ' + yvalues.length)
			}

			options = {}
			options.points = values
			options.strokewidth = stkwidth || 0.1
			options.pathcolor = color
			addPath(maingraph, plotname, options)

		}

		function updateplotF(maingraph, plotname, xvalues, yvalues) {
			values = []
			if (xvalues.length == yvalues.length) {
				for (m = 0; m < xvalues.length; m++) {
					values.push([xvalues[m], yvalues[m]])
				}
			}
			else {
				console.log('xvalue array length of ' + xvalues.length + ' doesnt match ' + yvalues.length)
			}

			// options = {}
			// options.points = values
			updatePath(maingraph, plotname, values)

		}

		// plotF('signaldisplaygraph','signal-plt', time, gWave[1], 'hsla(190, 100%, 50%, 1')
		// plotF('gwavedisplaygraph','gwave-plt', ntime, gWave[0], 'hsla(120, 100%, 50%, 1')


		function autocorrelation(v1, v2, mode) {
			mode = mode || 'full'
			if (mode == 'full') {

				midpv2 = parseInt((v2.length)/2) - 1 // Floor(v2/2) - 1

				l2 = v2.length
				l1 = v1.length

				sumarray = []


				for (rp = 1; rp <= l2 - 1; rp++) {
					sum = 0
					t2 = l2 - rp
					for (t1 = 0; t1 < rp; t1++) {
						pd = v1[t1]*v2[t2]
						sum = sum + pd
						t2 = t2 + 1
					}
					sumarray.push(sum)
				}

				for(st1 = 0; st1 <= (l1 - l2); st1++) {
					t1 = st1
					sum = 0
					for (t2 = 0; t2 < l2; t2++) {
						pd = v1[t1]*v2[t2]
						sum = sum + pd
						t1 = t1 + 1
					}
					sumarray.push(sum)
				}

				for (rp = 1; rp < l2; rp++) {
					t2 = 0
					sum = 0
					for (t1 = l1 - l2 + rp; t1 < l1; t1++) {
						pd = v1[t1]*v2[t2]
						sum = sum + pd
						t2 = t2 + 1
					}
					sumarray.push(sum)
				}

			}

			return [sumarray, midpv2]
		}


		// correlation = autocorrelation(gWave[1], gWave[0])
		

		// correlationToPlot = []

		// maxvaluecr = Number.NEGATIVE_INFINITY
		// minvaluecr = Number.POSITIVE_INFINITY
		// for (k = correlation[1]; k < (correlation[0].length - correlation[1] - 1); k++) {
		// 	correlationToPlot.push(correlation[0][k])
		// 	if (correlation[0][k] > maxvaluecr) {
		// 		maxvaluecr = correlation[0][k]
		// 	}
		// 	if (correlation[0][k] < minvaluecr) {
		// 		minvaluecr = correlation[0][k]
		// 	}
		// }


		// autocr = document.getElementById('autocrdisplayH')
		// graphoptions = {}
		// graphoptions.xmax = 3
		// graphoptions.xmin = -2
		// graphoptions.ymax = maxvaluecr
		// graphoptions.ymin = minvaluecr
		// graphoptions.axislocationX = 0
		// graphoptions.axislocationY = 0

		// graphoptions.xaxislabelvisibility = 'no'
		// graphoptions.yaxislabelvisibility = 'no'

		// graphoptions.ymajorgridlinesextension = 'yes'
		// graphoptions.xmajorgridlinesextension = 'yes'


		// // graphoptions.xaxisvisibility = 'no'
		// // graphoptions.yaxisvisibility = 'no'
		// graphoptions.axislocationX = -2
		// graphoptions.xmajorgridlinesvisibility = 'no'
		// graphoptions.ymajorgridlinesvisibility = 'no'
		// // graphoptions.ymajorgridlabelvisibility = 'no'
		// // graphoptions.xmajorgridlabelvisibility = 'no'

		// graphoptions.fontSize = 2

		// // graphoptions.unitAspectRatio = 'yes'
		// // graphoptions.fixAxis = 'yaxis'
		// // graphoptions.fixAxisStretchCentrally = 'yes'

		// // graphoptions.isComplexPlane = ''
		
		// addGraph(autocr, 'autocrgraph', graphoptions)

		sampleEvery = 2


		templatetimes = ntemplatetimes
		template = ntemplate

		newtemplatetimes = []
		maxvaluecrtime = Number.NEGATIVE_INFINITY
		minvaluecrtime = Number.POSITIVE_INFINITY
		for (k = 0; k < templatetimes.length; k = k + sampleEvery) {
			newtemplatetimes.push(templatetimes[k] - templatetimes[0])
			if (templatetimes[k] - templatetimes[0] > maxvaluecrtime) {
				maxvaluecrtime = templatetimes[k] - templatetimes[0]
			}
			if (templatetimes[k] - templatetimes[0] < minvaluecrtime) {
				minvaluecrtime = templatetimes[k] - templatetimes[0]
			}
		}

		newtemplate = []
		// maxvaluecr = Number.NEGATIVE_INFINITY
		// minvaluecr = Number.POSITIVE_INFINITY
		maxvaluecr = 0
		minvaluecr = 0
		maxcount = 0
		mincount = 0

		for (k = 0; k < template.length; k = k + sampleEvery) {
			newtemplate.push(Math.pow(10, 19)*template[k])
			if (Math.pow(10, 19)*template[k] >= 0) {
				maxvaluecr = maxvaluecr + Math.pow(10, 19)*template[k]
				maxcount = maxcount + 1
			}
			else if (Math.pow(10, 19)*template[k] < 0) {
				minvaluecr = minvaluecr + Math.pow(10, 19)*template[k]
				mincount = mincount + 1
			}
		}

		maxvaluecr = maxvaluecr*3/maxcount
		minvaluecr = minvaluecr*3/mincount


		gwavedisplay = document.getElementById('gwavedisplayH')
		graphoptions = {}
		graphoptions.xmax = newtemplatetimes.length
		graphoptions.xmin = 0
		graphoptions.ymax = maxvaluecr
		graphoptions.ymin = minvaluecr
		graphoptions.axislocationX = 0
		graphoptions.axislocationY = 0

		graphoptions.xaxislabelvisibility = 'no'
		graphoptions.yaxislabelvisibility = 'no'

		graphoptions.ymajorgridlinesextension = 'yes'
		graphoptions.xmajorgridlinesextension = 'yes'


		// graphoptions.xaxisvisibility = 'no'
		// graphoptions.yaxisvisibility = 'no'
		graphoptions.axislocationX = 0
		graphoptions.xmajorgridlinesvisibility = 'no'
		graphoptions.ymajorgridlinesvisibility = 'no'
		// graphoptions.ymajorgridlabelvisibility = 'no'
		// graphoptions.xmajorgridlabelvisibility = 'no'

		graphoptions.fontSize = 4.5

		// graphoptions.unitAspectRatio = 'yes'
		// graphoptions.fixAxis = 'yaxis'
		// graphoptions.fixAxisStretchCentrally = 'yes'

		// graphoptions.isComplexPlane = ''
		
		addGraph(gwavedisplay, 'gwavedisplaygraph', graphoptions)

		gwavetimestepdata = []
		for (k = 0; k < newtemplate.length; k++) {
			gwavetimestepdata.push(k)
		}

		plotF('gwavedisplaygraph','gwave-plt', gwavetimestepdata, newtemplate, 'hsla(10, 100%, 50%, 1', 0.5)


		// plotF('signaldisplaygraph','signal-plt', newstraintimes, newstrain, 'hsla(190, 100%, 50%, 1')

		// plotF('autocrgraph','correlation-plt', time, correlationToPlot, 'hsla(2, 100%, 50%, 1')



		newstrain = []
		// maxvaluecr = Number.NEGATIVE_INFINITY
		// minvaluecr = Number.POSITIVE_INFINITY
		maxvaluecr = 0
		minvaluecr = 0
		maxcount = 0
		mincount = 0


		for (k = 0; k < strain.length; k = k + sampleEvery) {
			newstrain.push(Math.pow(10, 19)*strain[k])
			if (Math.pow(10, 19)*strain[k] >= 0) {
				maxvaluecr = maxvaluecr + Math.pow(10, 19)*strain[k]
				maxcount = maxcount + 1
			}
			else if (Math.pow(10, 19)*strain[k] < 0) {
				minvaluecr = minvaluecr + Math.pow(10, 19)*strain[k]
				mincount = mincount + 1
			}
		}

		maxvaluecr = maxvaluecr*3/maxcount
		minvaluecr = minvaluecr*3/mincount


		newstraintimes = []
		maxvaluecrtime = Number.NEGATIVE_INFINITY
		minvaluecrtime = Number.POSITIVE_INFINITY
		for (k = 0; k < straintimes.length; k = k + sampleEvery) {
			newstraintimes.push(straintimes[k] - straintimes[0])
			if (straintimes[k] - straintimes[0] > maxvaluecrtime) {
				maxvaluecrtime = straintimes[k] - straintimes[0]
			}
			if (straintimes[k] - straintimes[0] < minvaluecrtime) {
				minvaluecrtime = straintimes[k] - straintimes[0]
			}
		}


		
		durationindex = gwavetimestepdata.length
		timestepdata = []

		for (m = 0; m < durationindex; m++) {
			timestepdata.push(m)
		}

		function getSegment(timeindex) {
			starttimeindex = timeindex
			endtimeindex = timeindex + durationindex
			returnarray = []
			for (m = starttimeindex; m < endtimeindex; m++) {
				if (typeof newstrain[m] !== 'undefined') {
					returnarray.push(newstrain[m])	
				}
				else {
					returnarray.push(0)
				}
			}
			return returnarray
		}


		looppoint = 0

		function playLoop() {
			loopinterval = setInterval(frame, 1);
			function frame() {
				plotarray = getSegment(looppoint)
				if (looppoint == 0) {
					plotF('signaldisplaygraph','signal-plt', timestepdata, plotarray, 'hsla(190, 100%, 50%, 1', 0.5)

				}
				else if (looppoint != 0) {
					updateplotF('signaldisplaygraph','signal-plt', timestepdata, plotarray)
				}
				

				options.text = newstraintimes[looppoint] - newstraintimes[0]
				looppoint = looppoint + 1
				updateText('signaldisplaygraph', 'timedisplaytext', options)
				// console.log(looptime)
				if (looppoint == straintimes.length) {
					clearInterval(loopinterval);
					looppoint = 0
				}
				
			}
		}

		playLoop()

		signaldisplay = document.getElementById('signaldisplayH')
		graphoptions = {}
		graphoptions.xmax = durationindex
		graphoptions.xmin = 0
		graphoptions.ymax = maxvaluecr
		graphoptions.ymin = minvaluecr
		graphoptions.axislocationX = 0
		graphoptions.axislocationY = 0

		graphoptions.xaxislabelvisibility = 'no'
		graphoptions.yaxislabelvisibility = 'no'

		graphoptions.ymajorgridlinesextension = 'yes'
		graphoptions.xmajorgridlinesextension = 'yes'


		// graphoptions.xaxisvisibility = 'no'
		// graphoptions.yaxisvisibility = 'no'
		graphoptions.axislocationX = 0
		graphoptions.xmajorgridlinesvisibility = 'no'
		graphoptions.ymajorgridlinesvisibility = 'no'
		// graphoptions.ymajorgridlabelvisibility = 'no'
		// graphoptions.xmajorgridlabelvisibility = 'no'

		graphoptions.fontSize = 4.5

		// graphoptions.unitAspectRatio = 'yes'
		// graphoptions.fixAxis = 'yaxis'
		// graphoptions.fixAxisStretchCentrally = 'yes'

		// graphoptions.isComplexPlane = ''
		
		addGraph(signaldisplay, 'signaldisplaygraph', graphoptions)

		options = {}
		options.y = maxvaluecr/2
		// console.log(options.x)
		options.x = durationindex*0.8
		options.textcolor = 'hsla(190, 20%, 0%, 1)'
		options.fontSize = 6
		options.text = 'test'
		if (darkmode) {
			// options.textcolor = 'hsla(190, 20%, 70%, 1)'
		}
		addText('signaldisplaygraph', 'timedisplaytext' , options)

		function deleteSegments(collection) {
			if (typeof collection != 'undefined') {
				for (f = 0; f < collection.length; f++) {
					collection[f].outerHTML = ''
				}
			}
		}

		function wheelHandle(event) {
			whlvalue = (event.wheelDeltaY)/Math.abs(event.wheelDeltaY)
			scalefactorup = 0.1
			scalefactordown = 0.1

			gdata = graphData['signaldisplaygraph']

			scale = gdata.ymax - gdata.ymin
			expstring = scale.toExponential().toString()
			ordery = (expstring.slice(expstring.indexOf('e') + 1)*(-1))
			// console.log(ordery)

			scale = gdata.xmax - gdata.xmin
			expstring = scale.toExponential().toString()
			orderx = (expstring.slice(expstring.indexOf('e') + 1)*(-1))
			// console.log(orderx)
			
			var rect = document.getElementById('signaldisplaygraph').getBoundingClientRect();
			posx = event.clientX - rect.left;
			posy = event.clientY - rect.top;

			posx = posx/rect.width
			posy = posy/rect.height
			posy = 1 - posy
			currentvalues = graphData['signaldisplaygraph']
			// console.log(whlvalue)
			if (whlvalue < 0) {
				newscalex = (currentvalues.xmax - currentvalues.xmin)*scalefactorup
				newscaley = (currentvalues.ymax - currentvalues.ymin)*scalefactorup
				options = {}
				options.xmin = currentvalues.xmin - (2*newscalex*(1 - posx))
				options.xmax = currentvalues.xmax + (2*newscalex*(posx))
				options.ymin = currentvalues.ymin - (2*newscaley*(1 - posy))
				options.ymax = currentvalues.ymax + (2*newscaley*(posy))
				updateGraphZoom('signaldisplaygraph', options)
			}
			else if (whlvalue >= 0 && orderx < 14 && ordery < 14) {
				newscalex = (currentvalues.xmax - currentvalues.xmin)*scalefactordown
				newscaley = (currentvalues.ymax - currentvalues.ymin)*scalefactordown
				options = {}
				options.xmin = currentvalues.xmin + (2*newscalex*(posx))
				options.xmax = currentvalues.xmax - (2*newscalex*(1 - posx))
				options.ymin = currentvalues.ymin + (2*newscaley*(posy))
				options.ymax = currentvalues.ymax - (2*newscaley*(1 - posy))
				updateGraphZoom('signaldisplaygraph', options)
			}
			
					


		}


		document.getElementById('signaldisplaygraph').addEventListener('wheel', wheelHandle)

		// https://gwpy.github.io/docs/latest/examples/signal/gw150914.html
		// Look here



		
		</script>


	</body>
<html>
